#!/usr/bin/env python3
"""Distribute unified MCP config to agent-specific formats.

Reads ~/.mcp.json (generated by generate-mcp-config.py) and:
- Merges MCP servers into ~/.gemini/settings.json
- Merges MCP servers into ~/.qwen/settings.json
- Codex: Uses host-mounted config.toml (user manages MCP on host)

Claude reads ~/.mcp.json directly, so no distribution needed.

Usage:
    distribute-mcp-config.py
"""

import argparse
import json
import logging
from pathlib import Path
from typing import Any, Dict

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
)
logger = logging.getLogger(__name__)


def load_mcp_config() -> Dict[str, Any]:
    """Load MCP config from ~/.mcp.json.

    Returns:
        Dict with mcpServers, or empty dict if not found
    """
    mcp_path = Path.home() / ".mcp.json"
    if mcp_path.exists():
        try:
            with open(mcp_path) as f:
                return json.load(f)
        except json.JSONDecodeError as e:
            logger.warning(f"Failed to parse {mcp_path}: {e}")
    return {}


def load_json_safe(path: Path) -> Dict[str, Any]:
    """Load JSON file, returning empty dict on error."""
    if path.exists():
        try:
            with open(path) as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError) as e:
            logger.warning(f"Failed to load {path}: {e}")
    return {}


def merge_mcp_into_settings(settings: Dict[str, Any], mcp_servers: Dict[str, Any]) -> Dict[str, Any]:
    """Merge MCP servers into existing settings.

    Preserves all existing settings, only updates mcpServers key.
    """
    result = settings.copy()
    result["mcpServers"] = mcp_servers
    return result


def write_json(path: Path, data: Dict[str, Any]) -> bool:
    """Write JSON file, creating parent directories.

    Returns:
        True if successful, False otherwise
    """
    try:
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, "w") as f:
            json.dump(data, f, indent=2)
            f.write("\n")  # Trailing newline
        return True
    except Exception as e:
        logger.error(f"Failed to write {path}: {e}")
        return False


def main():
    parser = argparse.ArgumentParser(description="Distribute MCP config to agents")
    parser.parse_args()

    # Load MCP config from ~/.mcp.json
    mcp_config = load_mcp_config()
    mcp_servers = mcp_config.get("mcpServers", {})

    if not mcp_servers:
        logger.info("No MCP servers in ~/.mcp.json, nothing to distribute")
        return

    logger.info(f"Found {len(mcp_servers)} MCP server(s) to distribute")

    home = Path.home()

    # Gemini: Merge MCP into existing settings.json
    gemini_path = home / ".gemini" / "settings.json"
    gemini_settings = load_json_safe(gemini_path)
    gemini_settings = merge_mcp_into_settings(gemini_settings, mcp_servers)
    if write_json(gemini_path, gemini_settings):
        logger.info(f"Updated {gemini_path} with {len(mcp_servers)} MCP servers")

    # Qwen: Merge MCP into existing settings.json
    qwen_path = home / ".qwen" / "settings.json"
    qwen_settings = load_json_safe(qwen_path)
    qwen_settings = merge_mcp_into_settings(qwen_settings, mcp_servers)
    if write_json(qwen_path, qwen_settings):
        logger.info(f"Updated {qwen_path} with {len(mcp_servers)} MCP servers")

    # Codex: Skip - uses host-mounted config.toml
    # User should configure MCP servers in their host ~/.codex/config.toml
    logger.info("Codex: Using host-mounted config.toml (MCP configured on host)")

    logger.info("MCP config distribution complete")


if __name__ == "__main__":
    main()
